- [x] Basin Rendering... See BlockModelShapes, ModelLoaderRegistry. Going to use Multipart models and Data Generators, E.g. split model into basin part (which will be static) and water part (which is generated). Create properties in Basin Block to expose water level, etc. Custom IStateMapper?
- [x] Spinning Wheel Block: Interacted w/ through right clicks. A spindle must be added first, then a certain amount of fiber. Afer this, right clicking spins the wheel. After a certain amount of spinning, the spindle becomes full and a thread item can be extracted. Multi-models and blockstates can be used to render varying levels of fiber and a spindle.
- [x] Color Word Localization
- [x] Better Mixing Algorithm
- [ ] Add Feature to boost Basin color saturation
	- Player can add one glowstone dust which boosts the basin's color saturation.
- [ ] Drafting Table
- [ ] Embroidery Table?
- [ ] Pattern items
- [x] Rewrite BasinTile using FSM
- [x] Rewrite SpinningWheel using FSM
- [x] Fiber Items
- [x] Brush Item
- [x] Item Color Helper
- [ ] TemplateItemModel rewrite
- [ ] Proper versioning
- [x] Fabric Item
	- [ ] IMPROVEMENT Allow changing RenderType to allow translucent textures in the GUI and using seperate atlas textures
	- [x] Create FabricLayer object
	- [x] Ability to dye and bleach
	- [x] More info on tooltips
	- [x] Make display name use pattern
	- [x] Allow patterns to be "loaded." Patterns should be able to specify their layers in a JSON file, which is loaded during setup.
		- Minecraft has interfaces like "IResourceManager" and "ISelectiveResourceReloadListener" which handle loading resources. We should probably try to implement these to handle pattern loading. "LootTableManager" might be a good resource.
		- Since "Material" is client-side, we will need to separate out the texture map from FabricPattern, perhaps into another class. This is also going to complicate loading. We might end up needing two files for each pattern: one to specify the layer names, recipe, etc., and another to specify the textures.
		- The best solution going forward would be to separate FabricPattern into a FabricPattern class, which would only contain the list of layers, and a "FabricTextures" class, which would map layers to textures. The layers could be specified when constructing the FabricPattern, avoiding the need for a file, and the textures could be specified in a resource file. Note that the fabric textures aren't a model. FabricItemModel handles creating models of fabric items by using their textures. We're also going to need a place to store the fabric textures associated with each FabricPattern. ModelBakery seems to be a good resource.
		- ModelBakery, ModelLoader, and ModelManager and work in tandem. The difference isn't exactly but it seems that ModelBakery performs the actual work (mostly in the processLoading method) and that ModelManager handles reloading and such. The main method for loading individual models seems to be ModelBakery.loadModel(...)
			- To load data from a resource file, ResourceManager is used to retrieve an IResource given a path. Then, you can process the input stream of the resource. BlockModel deserializes a JSON file. The is encapsulated by BlockModel.deserialize(...). Forge's "ExpandedBlockModelDeserializer" is handles some of the logic. One big feature of the ExpandedBlockModelDeserializer is the ability to specify a custom ModelLoader using the "loader" field.
			- To parse the JSON files, we need to construct a GSON instance. We can give it "type adapters" so that it knows how to parse objects. These require a Deserializer object. To create a Material instance, we need the location of an atlas texture as well as a texture file.
			- ParticleManager might be a good resource for performing atlas stitching and such.
			- One approach to texture stitching might be to use ModelManager's "special models." To do this, FabricItemModel would create a list of unbaked models for each fabric pattern when ModelRegistryEvent. It would mark each of these as a "special model" which would cause Minecraft to create atlases for textures used in them.
			- A better approach would be to let Minecraft know of the textures using IModelGeometry.getTextures(...) in FabricItemModel. This works!
			- Another issue is how Minecraft wants to use the block atlas for every item. I did some digging, and it looks like this is determined by the RenderType. Specifically, all items use the TRANSLUCENT_BLOCK_TYPE by default, which uses the block atlas. This behavior is defines in RenderTypeLookup.getRenderType(ItemStack stack) which is called by ItemRenderer.renderItem(...) If we can tell the game to use a render type for a specific item, we could solve this. Another solution would be to simply use the block texture. If we go this route, we might want users of FabricTextureManager to define the atlas instead, such as when generating item models.
	- Looks like ItemOverrideList can be used to override an Item's model dynamically. Will probably have to create a custom Model and ModelLoader class. Might create a new Atlas for patterns and such. Color different layers using Item Color. Note: Item Models don't generate their texture locations. I was being silly.
	- We will also have to register the ModelLoader. This can be done using ModelLoaderRegistry, and should be performed during the ModelRegistryEvent. The fabric item also needs to be hooked up to the ModelLoader, which is accomplished in the item's JSON model file.
	- Dynamic Bucket Model is a good source for creating custom item models.
	- "NewModelLoaderTest" included in Forge 1.16 is also a good source.
	- There are several methods for displaying fabrics. One method, discussed above, is creating a custom item model that creates quads for each layer of the fabric. This would mean more quads. Another possible issue would be z-fighting between quads of different layers, since they all use the same mask. This could be resolved by creating a more specialized quad generator. Another method of displaying fabric would be to combine each layer into an individual texture, and this this texture to render the item. This has the advantage of using less quads, and it would also really simplify armor rendering. Since a texture has to be created for each fabric, however, it could slow down the GPU. It also isn't clear how exactly this would be accomplished. Seeing how Minecraft generates atlas textures would be a good place to start.
	- https://github.com/MinecraftForge/MinecraftForge/blob/1.15.x/src/main/resources/assets/forge/models/item/bucket.json
	- https://github.com/MinecraftForge/MinecraftForge/src/test/java/net/minecraftforge/debug/client/model/NewModelLoaderTest.java
- [ ] Clothing
	- [ ] Model loading and caching
		- We can load block models from files and mark them to be registered using modelmanager. This can be done by creating an IFutureReloadListener, and hooking it up to Minecraft. It's not clear whether block models can support changing textures, however.
		- We should definitely cache models using some scheme. So we will probably need a ClothingModelManager class.
		- If we can choose what textures the model uses at render-time, then we can generate just a few models
		for each garment.
	- [ ] Clothing rendering
		- Vanilla Minecraft renders armor using LivingRenderer and ArmorLayer. LivingRenderer has a list of LayerRenderers, which ArmorLayer extends. LayerRenderers are rendered in LivingRenderer's render method. LayerRenderers can be added to a LivingRenderer using LivingRenderer.addLayer. There is a single LivingRender for each type of player "skin", which refer to the different Alyx and Steve models. These can be accessed from EntityRendererManager, using getSkinMap(), which maps "skins" to player renderers.
			- The PlayerRenderers are created during the EntityRendererManager constructor, which is called during the Minecraft constructor as The Minecraft instance has a single EntityRendererManager. It would probably be safe to attach more layer renderers during FMLClientSetup.
			- To render our clothing, we could attach a "ClothingLayerRenderer" to each PlayerRenderer that would handle rendering clothing. I have verified that this would work.
		- The texture to use when rendering an armor layer is determined by ArmorLayer.getArmorResource. The format of the texture location looks something like "minecraft:textures/models/armor/iron_layer_1", where the number at the end is 2 for leggings and 1 for all other parts. The location can also have a suffix such as "_overlay" specified by the type field of getArmorResource, which is used by leather armor to render layers with different colors.
		- ArmorLayer only has support for two different layers, so we probably won't end up using it. We will probably end up having to subclass LayerRenderer. 
		- The BipedModel used to render a part of armor is determined in ArmorLayer.renderModelPart. This calls a forge method IForgeItem.getArmorModel, which allows items to define their own BipedModel.
		- BipedModel defines its own geometry, but it could probably be subclassed.
- [x] Fix Brush Recipe
- [x] Pattern Registry
- [ ] Module System
- [ ] More efficient nearest-neighbor search for ColorWord
- [x] Better localization support
- [x] Delete ItemColorManager?
- [x] Make ThreadItem cache its translation key
- [ ] IMPROVEMENT Also make ThreadItem cache its RGBColor for rendering.
- [ ] IMPROVEMENT Move ColorWord definitions to a JSON file